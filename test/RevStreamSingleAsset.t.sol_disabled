// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

// foundry imports
import { Test, console2 } from "../lib/forge-std/src/Test.sol";

// oz imports
import { ERC1967Proxy } from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
import { Checkpoints } from "@openzeppelin/contracts/utils/structs/Checkpoints.sol";
import { ERC20Mock } from "@openzeppelin/contracts/mocks/token/ERC20Mock.sol";

// local imports
import { RevStreamSingleAsset } from "../src/RevStreamSingleAsset.sol";
import { RevenueStream } from "../src/RevenueStream.sol";
import { RevenueStreamETH } from "../src/RevenueStreamETH.sol";
import { RevenueDistributor } from "../src/RevenueDistributor.sol";
import { RWAVotingEscrow } from "../src/governance/RWAVotingEscrow.sol";
import { VotingEscrowVesting } from "../src/governance/VotingEscrowVesting.sol";
import { RWAToken } from "../src/RWAToken.sol";
import { DelegateFactory } from "../src/governance/DelegateFactory.sol";
import { Delegator } from "../src/governance/Delegator.sol";

import { IUniswapV2Router02 } from "../src/interfaces/IUniswapV2Router02.sol";

// local helper imports
import { Utility } from "./utils/Utility.sol";
import "./utils/Constants.sol";
import { VotingMath } from "../src/governance/VotingMath.sol";

/**
 * @title RWARevStreamSingleAssetTest
 * @author Chase Brown
 * @notice This test file contains the basic unit tests for the RevStreamSingleAsset contract.
 */
contract RWARevStreamSingleAssetTest is Utility {
    using VotingMath for uint256;

    // ~ Contracts ~

    RevStreamSingleAsset public singleAssetStream;
    RevenueStream public revStream;
    RevenueStreamETH public revStreamETH;
    RevenueDistributor public revDistributor;

    RWAVotingEscrow public veRWA;
    VotingEscrowVesting public vesting;
    RWAToken public rwaToken;
    DelegateFactory public delegateFactory;
    Delegator public delegator;

    ERC20Mock public mockRevToken1;
    ERC20Mock public mockRevToken2;

    // proxies
    ERC1967Proxy public singleAssetStreamProxy;
    ERC1967Proxy public revStreamETHProxy;
    ERC1967Proxy public revDistributorProxy;
    ERC1967Proxy public veRWAProxy;
    ERC1967Proxy public vestingProxy;
    ERC1967Proxy public rwaTokenProxy;
    ERC1967Proxy public delegateFactoryProxy;

    // ~ Variables ~

    address public WETH;

    function setUp() public {

        vm.createSelectFork(MUMBAI_RPC_URL);

        WETH = IUniswapV2Router02(MUMBAI_UNIV2_ROUTER).WETH();

        // ~ $RWA Deployment ~

        // Deploy $RWA Token implementation
        rwaToken = new RWAToken();

        // Deploy proxy for $RWA Token
        rwaTokenProxy = new ERC1967Proxy(
            address(rwaToken),
            abi.encodeWithSelector(RWAToken.initialize.selector,
                ADMIN,
                MUMBAI_UNIV2_ROUTER,
                address(0)
            )
        );
        rwaToken = RWAToken(payable(address(rwaTokenProxy)));


        // ~ Vesting Deployment ~

        // Deploy vesting contract
        vesting = new VotingEscrowVesting();

        // Deploy proxy for vesting contract
        vestingProxy = new ERC1967Proxy(
            address(vesting),
            abi.encodeWithSelector(VotingEscrowVesting.initialize.selector,
                ADMIN
            )
        );
        vesting = VotingEscrowVesting(address(vestingProxy));


        // ~ veRWA Deployment ~

        // Deploy veRWA implementation
        veRWA = new RWAVotingEscrow();

        // Deploy proxy for veRWA
        veRWAProxy = new ERC1967Proxy(
            address(veRWA),
            abi.encodeWithSelector(RWAVotingEscrow.initialize.selector,
                address(rwaToken),
                address(vesting),
                LAYER_Z, // Note: Layer Zero Endpoint -> For migration
                ADMIN
            )
        );
        veRWA = RWAVotingEscrow(address(veRWAProxy));


        // ~ Revenue Distributor Deployment ~

        // Deploy revDistributor contract
        revDistributor = new RevenueDistributor();

        // Deploy proxy for revDistributor
        revDistributorProxy = new ERC1967Proxy(
            address(revDistributor),
            abi.encodeWithSelector(RevenueDistributor.initialize.selector,
                ADMIN,
                address(0),
                address(veRWA)
            )
        );
        revDistributor = RevenueDistributor(payable(address(revDistributorProxy)));


        // ~ Revenue Stream Deployments ~

        // Deploy mock rev token 1
        mockRevToken1 = new ERC20Mock();


        // Deploy mock rev token 2
        mockRevToken2 = new ERC20Mock();


        // Deploy revStreamETH contract
        revStreamETH = new RevenueStreamETH();

        // Deploy proxy for revStreamETH
        revStreamETHProxy = new ERC1967Proxy(
            address(revStreamETH),
            abi.encodeWithSelector(RevenueStreamETH.initialize.selector,
                address(revDistributor),
                address(veRWA),
                ADMIN
            )
        );
        revStreamETH = RevenueStreamETH(payable(address(revStreamETHProxy)));


        // ~ Deploy RevStreamSingleAsset contracts ~

        // Deploy singleAssetStream contract.
        singleAssetStream = new RevStreamSingleAsset();

        // Deploy proxy for singleAssetStream
        singleAssetStreamProxy = new ERC1967Proxy(
            address(singleAssetStream),
            abi.encodeWithSelector(RevStreamSingleAsset.initialize.selector,
                address(revDistributor),
                MUMBAI_UNIV2_ROUTER,
                address(rwaToken), // single asset token. For testing is RWA
                ADMIN
            )
        );
        singleAssetStream = RevStreamSingleAsset(payable(address(singleAssetStreamProxy)));


        // ~ Delegator Deployment ~

        // Deploy Delegator implementation
        delegator = new Delegator();

        // Deploy DelegateFactory
        delegateFactory = new DelegateFactory();

        // Deploy DelegateFactory proxy
        delegateFactoryProxy = new ERC1967Proxy(
            address(delegateFactory),
            abi.encodeWithSelector(DelegateFactory.initialize.selector,
                address(veRWA),
                address(delegator),
                ADMIN
            )
        );
        delegateFactory = DelegateFactory(address(delegateFactoryProxy));


        // ~ Config ~

        vm.prank(ADMIN);
        revDistributor.updateRevenueStream(payable(address(revStreamETH)));

        // set votingEscrow on vesting contract
        vm.prank(ADMIN);
        vesting.setVotingEscrowContract(address(veRWA));

        // Grant minter role to address(this) & veRWA
        vm.startPrank(ADMIN);
        rwaToken.grantRole(MINTER_ROLE, address(this)); // for testing
        rwaToken.grantRole(MINTER_ROLE, address(veRWA)); // for RWAVotingEscrow:migrate
        rwaToken.grantRole(BURNER_ROLE, address(veRWA)); // for RWAVotingEscrow:migrate
        vm.stopPrank();

        // Exclude necessary addresses from RWA fees.
        vm.startPrank(ADMIN);
        rwaToken.excludeFromFees(address(veRWA), true);
        rwaToken.excludeFromFees(address(singleAssetStream), true);
        rwaToken.excludeFromFees(JOE, true);
        vm.stopPrank();

        // Mint Joe $RWA tokens
        rwaToken.mintFor(JOE, 1_000 ether);

        // grant revDistributor the DEPOSITOR role on revStreams
        vm.startPrank(ADMIN);
        revStreamETH.grantRole(DEPOSITOR_ROLE, address(revDistributor));
        vm.stopPrank();

        // grant singleRevStream contracts the CLAIMER_ROLE role on revStreams
        vm.startPrank(ADMIN);
        revStreamETH.grantRole(CLAIMER_ROLE, address(singleAssetStream));
        vm.stopPrank();


        // ~ Create Pools ~

        // pair 1: ETH / mockToken1
        // pair 2: ETH / mockToken2
        // pair 3: RWA / mockToken1
        // pair 4: RWA / mockToken2
        // pair 5: RWA / ETH

        // pair 1

        uint256 ETH_DEPOSIT = 10 ether;
        uint256 TOKEN_DEPOSIT = 100_000 ether;

        mockRevToken1.mint(address(this), TOKEN_DEPOSIT);
        mockRevToken1.approve(address(MUMBAI_UNIV2_ROUTER), TOKEN_DEPOSIT);

        IUniswapV2Router02(MUMBAI_UNIV2_ROUTER).addLiquidityETH{value: ETH_DEPOSIT}(
            address(mockRevToken1),
            TOKEN_DEPOSIT,
            TOKEN_DEPOSIT,
            ETH_DEPOSIT,
            address(this),
            block.timestamp
        );

        // pair 2

        ETH_DEPOSIT = 10 ether;
        TOKEN_DEPOSIT = 100_000 ether;

        mockRevToken2.mint(address(this), TOKEN_DEPOSIT);
        mockRevToken2.approve(address(MUMBAI_UNIV2_ROUTER), TOKEN_DEPOSIT);

        IUniswapV2Router02(MUMBAI_UNIV2_ROUTER).addLiquidityETH{value: ETH_DEPOSIT}(
            address(mockRevToken2),
            TOKEN_DEPOSIT,
            TOKEN_DEPOSIT,
            ETH_DEPOSIT,
            address(this),
            block.timestamp
        );

        // pair 3

        uint256 RWA_DEPOSIT = 100_000 ether;
        TOKEN_DEPOSIT = 100_000 ether;

        rwaToken.mint(RWA_DEPOSIT);
        rwaToken.approve(address(MUMBAI_UNIV2_ROUTER), RWA_DEPOSIT);

        mockRevToken1.mint(address(this), TOKEN_DEPOSIT);
        mockRevToken1.approve(address(MUMBAI_UNIV2_ROUTER), TOKEN_DEPOSIT);

        IUniswapV2Router02(MUMBAI_UNIV2_ROUTER).addLiquidity(
            address(rwaToken),
            address(mockRevToken1),
            RWA_DEPOSIT, // tokenA desired
            TOKEN_DEPOSIT, // tokenB desired
            RWA_DEPOSIT, // tokenA minimum
            TOKEN_DEPOSIT, // tokenB minimum
            address(this),
            block.timestamp
        );

        // pair 4

        RWA_DEPOSIT = 100_000 ether;
        TOKEN_DEPOSIT = 100_000 ether;

        rwaToken.mint(RWA_DEPOSIT);
        rwaToken.approve(address(MUMBAI_UNIV2_ROUTER), RWA_DEPOSIT);

        mockRevToken2.mint(address(this), TOKEN_DEPOSIT);
        mockRevToken2.approve(address(MUMBAI_UNIV2_ROUTER), TOKEN_DEPOSIT);

        IUniswapV2Router02(MUMBAI_UNIV2_ROUTER).addLiquidity(
            address(rwaToken),
            address(mockRevToken2),
            RWA_DEPOSIT, // tokenA desired
            TOKEN_DEPOSIT, // tokenB desired
            RWA_DEPOSIT, // tokenA minimum
            TOKEN_DEPOSIT, // tokenB minimum
            address(this),
            block.timestamp
        );

        // pair 5

        ETH_DEPOSIT = 10 ether;
        RWA_DEPOSIT = 100_000 ether;

        rwaToken.mint(RWA_DEPOSIT);
        rwaToken.approve(address(MUMBAI_UNIV2_ROUTER), RWA_DEPOSIT);

        IUniswapV2Router02(MUMBAI_UNIV2_ROUTER).addLiquidityETH{value: ETH_DEPOSIT}(
            address(rwaToken),
            RWA_DEPOSIT,
            RWA_DEPOSIT,
            ETH_DEPOSIT,
            address(this),
            block.timestamp
        );
    }


    // -------
    // Utility
    // -------

    /// @dev Returns the amount of $RWA tokens quoted for `amount` tokens.
    function _getQuote(address tokenIn, uint256 amount) internal view returns (uint256) {
        address[] memory path = new address[](2);

        path[0] = tokenIn;
        path[1] = address(rwaToken);

        uint256[] memory amounts = 
            IUniswapV2Router02(MUMBAI_UNIV2_ROUTER).getAmountsOut(amount, path);

        return amounts[1];
    }

    /// @dev Returns the amount of ETH tokens quoted for `amount` tokens.
    function _getQuoteETH(address tokenIn, uint256 amount) internal view returns (uint256) {
        address[] memory path = new address[](2);

        path[0] = tokenIn;
        path[1] = WETH;

        uint256[] memory amounts = 
            IUniswapV2Router02(MUMBAI_UNIV2_ROUTER).getAmountsOut(amount, path);

        return amounts[1];
    }

    /// @dev Used to create a veRWA holder.
    function _createStakeholder(address actor, uint256 amountLock) internal returns (uint256 tokenId) {
        // Mint Joe more$RWA tokens
        rwaToken.mintFor(actor, amountLock);

        uint256 duration = (1 * 30 days);

        // mint Joe veRWA token
        vm.startPrank(actor);
        rwaToken.approve(address(veRWA), amountLock);
        tokenId = veRWA.mint(
            actor,
            uint208(amountLock),
            duration
        );
        vm.stopPrank();
    }


    // ------------------
    // Initial State Test
    // ------------------

    /// @dev Verifies initial state of RevStreamSingleAsset contracts.
    function test_singleStream_init_state() public {
        // TODO
        // single streams have claimer role
        // wl on rwa
    }


    // ----------
    // Unit Tests
    // ----------

    /// @dev Verifies proper return values when RevStreamSingleAsset::claimableAsSingleAsset() is called.
    function test_singleStream_claimableAsSingleAsset() public {

        // ~ Config ~

        uint256 amountForLock = 10_000 ether;
        _createStakeholder(JOE, amountForLock);

        uint256 amountTokens = 1_000 ether;
        uint256 amountETH = 1 ether;

        mockRevToken1.mint(address(revDistributor), amountTokens);
        mockRevToken2.mint(address(revDistributor), amountTokens);
        deal(address(revDistributor), amountETH);

        // ~ Sanity check ~

        assertEq(mockRevToken1.balanceOf(address(revDistributor)), amountTokens);
        assertEq(mockRevToken2.balanceOf(address(revDistributor)), amountTokens);
        assertEq(address(revDistributor).balance, amountETH);

        // distribute streams from Revenue Distributor
        vm.prank(ADMIN);
        revDistributor.distributeAll();

        //assertEq(mockRevToken1.balanceOf(address(revStream1)), amountTokens);
        //assertEq(mockRevToken2.balanceOf(address(revStream2)), amountTokens);
        assertEq(address(revStreamETH).balance, amountETH);

        // Skip to avoid FutureLookup error
        skip(1);

        // ~ State check ~

        assertEq(revStreamETH.claimable(JOE), amountETH);

        uint256 quote1 = _getQuote(address(mockRevToken1), amountTokens);
        uint256 quote2 = _getQuote(address(mockRevToken2), amountTokens);
        uint256 quote3 = _getQuote(WETH, amountETH);

        assertEq(singleAssetStream.claimableAsSingleAsset(JOE), quote1 + quote2 + quote3);
        assertGt(quote1, 0);
        assertGt(quote2, 0);
        assertGt(quote3, 0);
    }

    /// @dev Verifies proper return values when RevStreamSingleAssetETH::claimableAsETH() is called.
    function test_singleStream_claimableAsETH() public {

        // ~ Config ~

        uint256 amountForLock = 10_000 ether;
        _createStakeholder(JOE, amountForLock);

        uint256 amountTokens = 1_000 ether;
        uint256 amountETH = 1 ether;

        mockRevToken1.mint(address(revDistributor), amountTokens);
        mockRevToken2.mint(address(revDistributor), amountTokens);
        deal(address(revDistributor), amountETH);

        // ~ Sanity check ~

        assertEq(mockRevToken1.balanceOf(address(revDistributor)), amountTokens);
        assertEq(mockRevToken2.balanceOf(address(revDistributor)), amountTokens);
        assertEq(address(revDistributor).balance, amountETH);

        // distribute streams from Revenue Distributor
        vm.prank(ADMIN);
        revDistributor.distributeAll();

        //assertEq(mockRevToken1.balanceOf(address(revStream1)), amountTokens);
        //assertEq(mockRevToken2.balanceOf(address(revStream2)), amountTokens);
        assertEq(address(revStreamETH).balance, amountETH);

        // Skip to avoid FutureLookup error
        skip(1);

        // ~ State check ~

        assertEq(revStreamETH.claimable(JOE), amountETH);

        uint256 quote1 = _getQuoteETH(address(mockRevToken1), amountTokens);
        uint256 quote2 = _getQuoteETH(address(mockRevToken2), amountTokens);
        uint256 quote3 = amountETH;

        assertGt(quote1, 0);
        assertGt(quote2, 0);
    }

    /// @dev Verifies proper state changes when a stakeholder claims their revenue via RevStreamSingleAsset::claimAsSingleAsset().
    function test_singleStream_claimAsSingleAsset() public {
     
        // ~ Config ~

        uint256 amountForLock = 10_000 ether;
        _createStakeholder(JOE, amountForLock);

        uint256 amountTokens = 1_000 ether;
        uint256 amountETH = 1 ether;

        mockRevToken1.mint(address(revDistributor), amountTokens);
        mockRevToken2.mint(address(revDistributor), amountTokens);
        deal(address(revDistributor), amountETH);

        // ~ Sanity check ~

        assertEq(mockRevToken1.balanceOf(address(revDistributor)), amountTokens);
        assertEq(mockRevToken2.balanceOf(address(revDistributor)), amountTokens);
        assertEq(address(revDistributor).balance, amountETH);

        // distribute streams from Revenue Distributor
        vm.prank(ADMIN);
        revDistributor.distributeAll();

        //assertEq(mockRevToken1.balanceOf(address(revStream1)), amountTokens);
        //assertEq(mockRevToken2.balanceOf(address(revStream2)), amountTokens);
        assertEq(address(revStreamETH).balance, amountETH);

        // Skip to avoid FutureLookup error
        skip(1);

        // ~ Pre-State check ~

        assertEq(revStreamETH.claimable(JOE), amountETH);

        uint256 totalClaimable;

        totalClaimable += _getQuote(address(mockRevToken1), amountTokens);
        totalClaimable += _getQuote(address(mockRevToken2), amountTokens);
        totalClaimable += _getQuote(WETH, amountETH);

        assertEq(singleAssetStream.claimableAsSingleAsset(JOE), totalClaimable);
     
        uint256 preBal = rwaToken.balanceOf(JOE);

        // ~ Joe executed claimAsSingleAsset ~

        vm.prank(JOE);
        singleAssetStream.claimAsSingleAsset(JOE);

        // ~ Post-state check ~

        assertEq(revStreamETH.claimable(JOE), 0);
        assertEq(singleAssetStream.claimableAsSingleAsset(JOE), 0);

        assertGt(rwaToken.balanceOf(JOE), preBal);
        assertEq(rwaToken.balanceOf(JOE), preBal + totalClaimable);
    }

    /// @dev Verifies proper values when RevStreamSingleAsset::claimableAsSingleAsset() for a delegatee.
    function test_singleStream_claimableAsSingleAsset_delegatee() public {

        // ~ Config ~

        uint256 amountForLock = 10_000 ether;
        _createStakeholder(ALICE, amountForLock);

        // ALICE delegates to JOE
        vm.prank(ALICE);
        veRWA.delegate(JOE);

        uint256 amountTokens = 1_000 ether;
        uint256 amountETH = 1 ether;

        mockRevToken1.mint(address(revDistributor), amountTokens);
        mockRevToken2.mint(address(revDistributor), amountTokens);
        deal(address(revDistributor), amountETH);

        // ~ Sanity check ~

        assertEq(mockRevToken1.balanceOf(address(revDistributor)), amountTokens);
        assertEq(mockRevToken2.balanceOf(address(revDistributor)), amountTokens);
        assertEq(address(revDistributor).balance, amountETH);

        // distribute streams from Revenue Distributor
        vm.prank(ADMIN);
        revDistributor.distributeAll();

        //assertEq(mockRevToken1.balanceOf(address(revStream1)), amountTokens);
        //assertEq(mockRevToken2.balanceOf(address(revStream2)), amountTokens);
        assertEq(address(revStreamETH).balance, amountETH);

        // Skip to avoid FutureLookup error
        skip(1);

        // ~ State check ~

        assertEq(veRWA.balanceOf(ALICE), 1);
        assertEq(veRWA.balanceOf(JOE), 0);

        assertEq(revStreamETH.claimable(JOE), amountETH);

        uint256 quote1 = _getQuote(address(mockRevToken1), amountTokens);
        uint256 quote2 = _getQuote(address(mockRevToken2), amountTokens);
        uint256 quote3 = _getQuote(WETH, amountETH);

        assertEq(singleAssetStream.claimableAsSingleAsset(ALICE), 0);
        assertEq(singleAssetStream.claimableAsSingleAsset(JOE), quote1 + quote2 + quote3);
        assertGt(quote1, 0);
        assertGt(quote2, 0);
        assertGt(quote3, 0);
    }

    /// @dev Verifies proper values when RevStreamSingleAssetETH::claimableAsETH() for a delegatee.
    function test_singleStream_claimableAsETH_delegatee() public {

        // ~ Config ~

        uint256 amountForLock = 10_000 ether;
        _createStakeholder(ALICE, amountForLock);

        // ALICE delegates to JOE
        vm.prank(ALICE);
        veRWA.delegate(JOE);

        uint256 amountTokens = 1_000 ether;
        uint256 amountETH = 1 ether;

        mockRevToken1.mint(address(revDistributor), amountTokens);
        mockRevToken2.mint(address(revDistributor), amountTokens);
        deal(address(revDistributor), amountETH);

        // ~ Sanity check ~

        assertEq(mockRevToken1.balanceOf(address(revDistributor)), amountTokens);
        assertEq(mockRevToken2.balanceOf(address(revDistributor)), amountTokens);
        assertEq(address(revDistributor).balance, amountETH);

        // distribute streams from Revenue Distributor
        vm.prank(ADMIN);
        revDistributor.distributeAll();

        //assertEq(mockRevToken1.balanceOf(address(revStream1)), amountTokens);
        //assertEq(mockRevToken2.balanceOf(address(revStream2)), amountTokens);
        assertEq(address(revStreamETH).balance, amountETH);

        // Skip to avoid FutureLookup error
        skip(1);

        // ~ State check ~

        assertEq(veRWA.balanceOf(ALICE), 1);
        assertEq(veRWA.balanceOf(JOE), 0);

        assertEq(revStreamETH.claimable(JOE), amountETH);

        uint256 quote1 = _getQuoteETH(address(mockRevToken1), amountTokens);
        uint256 quote2 = _getQuoteETH(address(mockRevToken2), amountTokens);
        uint256 quote3 = amountETH;

        assertGt(quote1, 0);
        assertGt(quote2, 0);
    }

    /// @dev Verifies proper state changes when a delegatee claims their revenue via RevStreamSingleAsset::claimAsSingleAsset().
    function test_singleStream_claimAsSingleAsset_delegatee() public {

        // ~ Config ~

        uint256 amountForLock = 10_000 ether;
        _createStakeholder(ALICE, amountForLock);

        // ALICE delegates to JOE
        vm.prank(ALICE);
        veRWA.delegate(JOE);

        uint256 amountTokens = 1_000 ether;
        uint256 amountETH = 1 ether;

        mockRevToken1.mint(address(revDistributor), amountTokens);
        mockRevToken2.mint(address(revDistributor), amountTokens);
        deal(address(revDistributor), amountETH);

        // ~ Sanity check ~

        assertEq(mockRevToken1.balanceOf(address(revDistributor)), amountTokens);
        assertEq(mockRevToken2.balanceOf(address(revDistributor)), amountTokens);
        assertEq(address(revDistributor).balance, amountETH);

        // distribute streams from Revenue Distributor
        vm.prank(ADMIN);
        revDistributor.distributeAll();

        //assertEq(mockRevToken1.balanceOf(address(revStream1)), amountTokens);
        //assertEq(mockRevToken2.balanceOf(address(revStream2)), amountTokens);
        assertEq(address(revStreamETH).balance, amountETH);

        // Skip to avoid FutureLookup error
        skip(1);

        // ~ Pre-State check ~

        assertEq(revStreamETH.claimable(JOE), amountETH);

        uint256 totalClaimable;

        totalClaimable += _getQuote(address(mockRevToken1), amountTokens);
        totalClaimable += _getQuote(address(mockRevToken2), amountTokens);
        totalClaimable += _getQuote(WETH, amountETH);

        assertEq(singleAssetStream.claimableAsSingleAsset(JOE), totalClaimable);
        assertEq(singleAssetStream.claimableAsSingleAsset(ALICE), 0);
     
        uint256 preBal = rwaToken.balanceOf(JOE);

        // ~ Joe executed claimAsSingleAsset ~

        vm.prank(JOE);
        singleAssetStream.claimAsSingleAsset(JOE);

        // ~ Post-state check ~

        assertEq(veRWA.balanceOf(ALICE), 1);
        assertEq(veRWA.balanceOf(JOE), 0);

        assertEq(revStreamETH.claimable(JOE), 0);
        assertEq(singleAssetStream.claimableAsSingleAsset(JOE), 0);

        assertGt(rwaToken.balanceOf(JOE), preBal);
        assertEq(rwaToken.balanceOf(JOE), preBal + totalClaimable);
    }
}